---
title: "Saldana, Montano, et al. -- scRNA-seq: 08_WT_slingshot"
author: "Luis Montano"
date: '2023-09-06'
output: html_document
params:
  inputdata: '~/path/to/input_data/'
  plotpath: '~/path/to/plots/'
  cachedir: '~/path/to/cachedir/'
  outpath: '~/mnt_out/figures/'
  resourcepath: "~/mnt_resources/"
  gtfpath: '~/path/to/gencode.v40.annotation.gtf.gz'
  downloadedfilepath: '~/path/to/downloaded_files/'
  fig_width: 6
  fig_height: 4
---

# Pseudotime trajectory analysis of the MES-SYM trajectory in the wild type dataset and associated genes

## Dependencies

This script depends on some functions and objects on R/importdata.R and the script R/scutils. R It also depends on the outputs generated by scrna/03

## Outputs

* Contents of Supplementary figure 3 and trajectory associated genes


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load functions and relevant variables, and prepare workspace

```{r}
source("~/R/scutils.R")
source("~/R/importdata.R")

vfeatures=5000
pcdims=30
umapdims=10
sz=.02
tsca=200

################################################################################
# setting UMAP parameters
################################################################################
  wtumapdims=10
  wtnn=30
  wtag="WT"
  wtmd=0.4
  pval=0.05
  minfc=.3
  fdr=0.05
  selecttop=50
################################################################################
#### comparison heatmap parameters
################################################################################  
  numcells=100
  
################################################################################
# tradeSeq trajectory association parameters  
################################################################################
nkn=5  # number of fitGAM knots for tradeSeq
lt=1 # minimum log fold change i the results
nmr=2 # index of the associated trajectory to analyse  
marktransition=F
numsignificant=400 # number of top significant genes to be recovered
##number of evenly spaced bins in lambda and number of cells for each
nsteps=50 #number of steps on which to divide the lambda
samplesize=50 #number of cells per bin

################################################################################
# heatmap plotting parameters
################################################################################
cpalette=c("#0B9988", "#f7f7f7", "#F9AD03") #petrol gold
br=seq(-4,4,.1)
cmap=colorRampPalette(cpalette, space="rgb")(length(br))
sca=3 #for 50, use 3. for 150 png, use 10 first
rr=600 #resolution
clus=T # whether to cluster the genes in the heatmap
nk=5 # number of gene clusters in heatmap dendrogram.
```

load integrated single cell experiment with data across all datasets

```{r}

 fullreload=T

simpleCache("seurat_WT_processed_clusters_markers", {scwt}, 
            #recreate=T,
            reload=T,
            assignToVar="scwt")

```

## Plotting the WT UMAP across stages

```{r}
#umapchoice from script 03
wtumap.pars=list()
wtumap.pars[[22]]=list(assay="sctscvi", umapname="wtumap.fullscvi822", reduction.key=prepare.rk("wtumap.fullscvi822"), pcared="scvi", nn=50, md=.5, umapdims=8, umapclusres=0.08)

umapchoice=22
  ur=wtumap.pars[[wtumapchoice]]$umapname
  ass=wtumap.pars[[wtumapchoice]]$assay
  red=wtumap.pars[[wtumapchoice]]$pcared
  rk=wtumap.pars[[wtumapchoice]]$reduction.key
  nn=wtumap.pars[[wtumapchoice]]$nn
  md=wtumap.pars[[wtumapchoice]]$md
  wtur=ur
  wtass=ass
  wtred=red
  wtrk=rk
  wtnn=nn
  wtmd=md
  
  umapdims=wtumap.pars[[wtumapchoice]]$umapdims
  wtumapdims=umapdims

  varr="type3"
tpng(paste_("UMAPwt", varr), wi=w*sca, he=w*sca, res=rr)
wp=ggumap(scwt, colorby=varr, labelby="WT.clusters", reduction=ur, reduction.key=rk, colorlist=allcolors, ssca=350)+NoAxes()+NoLegend()

dev.off()
wp
```

Defining parameter sets for the slingshot and tradeseq runs


```{r echo=FALSE}
library(slingshot)
library(tradeSeq)


######################################################
#setting up global and specifi parameters
#####################################################
slipars=list(
  scpmessym=list(dataset="WT", redd.use="sctharmony50dims", clusvarname="wtumap.sctharmony_nngraph_res.0.6", clustersubset=c(16,17,19,14,23,12,13,22,0,18,13,6), subsetlabel="MES_to_SYM",trajectoryvarname="WT.clusters7",  start.clus=16, end.clus=6, comps=c(1,2), mrkrs=c("ZFP36L1","IGDCC3","RARRES2","BCL2L12","MDFI","DAB2", "IFITM2"  , "RAB34" ,  "HMGN3" ,  "RAB13" ,  "SFRP1"), numsignificant=250, nkn=3, nk=5),
  scpmessym2=list(dataset="WT", ass.use="sctharwt", redd.use="sctharwt50dims", clusvarname="wtumap.sctharwt_nngraph_res.0.6", clustersubset=c(17,13,12,1,19,15,3,20,2), subsetlabel="ggpMES_to_SYM",trajectoryvarname="wtumap.sctharmony_nngraph_res.0.6",  start.clus=13,end.clus=2, comps=c(1,2),  mrkrs=NULL),
    scvimessym1=list(dataset="WT", ass.use="scvi", redd.use="scvi", clusvarname="WT.clusters", clustersubset=c("C11", "C12","C13","C14"), subsetlabel="scviMES_to_SYM",trajectoryvarname="WT.clusters",  start.clus="C11",end.clus="C14", comps=c(1,2),  mrkrs=NULL, conditionsubset="cWT")
)

################################################################################
# choosing parameter set
################################################################################

#parameter choices for the mes-sym transition, the bridge day 14-day 19 transitions, and the NOTCH-driven NC-sensory neuron transition

choice=3#choose transition

pars=slipars[[choice]]
clustersubset=pars$clustersubset
clusvarname=pars$clusvarname
subsetlabel=pars$subsetlabel
start.clus=pars$start.clus
end.clus=pars$end.clus
comps=pars$comps
mrkrs=pars$mrkrs
dataset=pars$dataset
curves=pars$curves
redd=pars$redd.use
conditionsubset=pars$conditionsubset



reprocessdataset=F
if(pars$trajectoryvarname!=pars$clusvarname){
  trajectoryvarname=pars$trajectoryvarname}else{trajectoryvarname=clusvarname}


#tradeSeq parameters
numfold=200
wt=0.2
pval=0.01
#log2(3)
ordervar="waldStat"
scolorby="ccondition"
```

Subsetting the dataset into the relevant clusters for the transition

```{r}
fullrecreate=F
fullreload=T
ass.local="sctlocal"
ass.use="sctscvi"
  
  simpleCache(paste_(dataset, ass.local, redd, "subset_", subsetlabel, "clusters", paste(clustersubset, collapse="_"),"forslingshot"), {
    
    #plotting parameters
  #number of steps in which to linearly bin the lambda
    
  nsteps=20
  samplesize=20
  nk =3 # number of pattern clusters in the final heatmap
  

    cells=scwt %>% metadata %>% filter( !!sym(clusvarname) %in% clustersubset, ccondition %in% conditionsubset) %>% rownames
    s10=scwt[, cells]
    fcat("checking whether assay ", ass.local, "is inside the object")
  
  if(!(ass.local %in% (s10@assays %>% names))){

    fcat("sctransform to obtain assay", ass.local)
s10=SCTransform(s10, assay="RNA", new.assay.name=ass.local, vars.to.regress="ccvar", method="glmGamPoi", verbose=T)
  }
  
  
  DefaultAssay(s10)=ass.use
  fcat("printing metadata")
  ###plotting 15 and 16 just to make sure they make sense
  clusvarname1="stage"
  uu2= DimPlot(s10, reduction=ur, group.by=clusvarname1, cols=allcolors[[clusvarname1]])
  clusvarname2="Phase"
  uu2c=DimPlot(s10, reduction=ur, group.by=clusvarname2, cols=allcolors[[clusvarname2]])
  clusvarname3="stage"
  uu2s=DimPlot(s10,  reduction=ur,group.by=clusvarname3, label=T, cols=allcolors[[clusvarname]])
  clusvarname4="ccondition"
  uu2d=DimPlot(s10,  reduction=ur,group.by=clusvarname4, label=T, cols=allcolors[[clusvarname4]])
  
  rr=600
  sca=20
  tpng(path=params$plotpath, paste_("UMAP_clusternoprocess", subsetlabel, paste(clustersubset, collapse="_")),height=w*sca, width=w*sca, res=rr)
  print((uu2+NoAxes())+(uu2c+NoAxes())+uu2s+NoAxes()+(uu2d+NoAxes()))
dev.off()


####now reprocessing the PCA and visualising
if(redd=="pcalocal"){
  graph.name="local"
  s10=RunPCA(s10, assay=ass.local, reduction.name="pcalocal", reduction.key="pcalocal_")

}
s10}, assignToVar="s10", recreate=fullrecreate, reload=fullreload)

allcomps=t(combn(c(1:5),2)) #more natural to me as two columns
lapply(1:10, function(x){
  dms=allcomps[x, ]#n77dims[1:x]

  
  ##############################################################################
  # preparing some quick auxiliary plots to visualise the reduction
  ##############################################################################
  
  
  varr="type"
  uu2= DimPlot(s10, reduction=redd,dims=dms, group.by=varr, cols=allcolors[[varr]])
  varr="ccondition"
  uu2c=DimPlot(s10, reduction=redd, dims=dms,group.by=varr, cols=allcolors[[varr]])
  varr="stage"
  uu2s=DimPlot(s10,  reduction=redd,dims=dms,group.by=varr, label=T, cols=allcolors[[varr]])
  varr="Phase"
  uu2d=DimPlot(s10,  reduction=redd,dims=dms,group.by=varr, label=T, cols=allcolors[[varr]])
  rr=600
  sca=20
  tpng(path=params$plotpath, paste_("PCAsubset" ,ass.local, redd, subsetlabel, paste(clustersubset, collapse="_"), "pca_condition_dms_", paste(dms, collapse="_")),height=w*sca, width=w*sca, res=rr)
  print((uu2+NoAxes())+(uu2c+NoAxes())+(uu2s+NoAxes())+(uu2d+NoAxes()))
  dev.off()
})





```

## Performing slingshot to obtain Pseudotime ordering of cells

```{r}

library(tidyr)

rd=Embeddings(s10, reduction=redd)[,comps]
cl=metadata(s10)%>% pull(!!sym(trajectoryvarname))


sli=NULL
simpleCache(paste_("slingshotsubsetlabel",subsetlabel, "clusters", paste(clustersubset, collapse="_")), {
  
  
  #actual slingshot run
  sli <- slingshot(rd, clusterLabels = cl, start.clus=start.clus, end.clus=end.clus) 
  
  sli
  
}, assignToVar="sli", recreate=fullrecreate, reload=fullreload)

if (is.null(pars$curves)){
  curves=1:length(SlingshotDataSet(sli)@lineages)
  
}

#reformatting slingshot output into a dataframe

tidy_ss_output2=function(sli){
 mdf=sling_cell_df(sli) %>% select(starts_with("pseudotime"), starts_with("order"))
  
  curves=1:length(SlingshotDataSet(sli)@lineages)
  lineagenames=SlingshotDataSet(sli)@lineages %>% names
  
  df=lapply(lineagenames, function(x){
  list(SlingshotDataSet(sli)@curves[[x]]$lambda, SlingshotDataSet(sli)@curves$Lineage1$w) %>% Reduce(cbind, .) %>% as.data.frame %>% givecolnames(., nms=c(paste0(x, ".lambda"),paste0(x, ".w")))  
   
}) %>% Reduce(cbind, .)  %>% cbind(., sli$reducedDim)
  
  df = df %>% mutate(cell_id=rownames(df),mean_pseudotime=mdf[rownames(df), ]$mean_pseudotime, mean_order=mdf[rownames(df), ]$mean_order)
  df = cbind(df, mdf[rownames(df),])
  df
}

## assembling a dataframe including all the output from all found principal curves


curvedf= function(sli, x) cbind(SlingshotDataSet(sli)@curves[[paste0("Lineage",x)]]$s, SlingshotDataSet(sli)@curves[[paste0("Lineage",x)]]$ord) %>% as.data.frame %>% givecolnames(., ind=3, nms=c("ord"))

simpleCache(paste_("slidf_", subsetlabel), {
  slidf=tidy_ss_output2(sli) %>%
    mutate(clusters= (s10 %>% metadata %>% select(!!sym(clusvarname)))[cell_id,], type=(s10 %>% metadata)[cell_id,"type"], type3=(s10 %>% metadata)[cell_id,"type3"], ccondition=(s10 %>% metadata %>% select(ccondition))[cell_id,])
}, assignToVar="slidf", reload=F, recreate=T)

###flipped the PC_1 for ore intuitive plotting. 
if (length(pars$comps)>2){
  combarray=combn(pars$comps, 2);
  complist =lapply(1:ncol(combarray), function(x) combarray[,x]) 
}else{complist=list(comps)}


################################################################################
# Supplementary figure 3a (top) plotting the slingshot trajectories on the reduction
################################################################################

sz=0.05
legsize=1
lapply(c("ccondition", "type3"), function(scolorby){
  sp2=lapply(1:length(complist), function(cp){
    comps=complist[[cp]]
    fcat(comps)
    sp1=lapply(1:length(curves) , function(cs){
      ggplot()+geom_point(data=slidf, size=sz,aes(x=!!sym(paste0(redd, "_", comps[1])), y=!!sym(paste0(redd, "_", comps[2])),  color = !!sym(scolorby)))+
        geom_path(data= curvedf(sli, cs ) %>% arrange(ord), aes(x=!!sym(paste0(redd, "_", comps[1])), y=!!sym(paste0(redd, "_", comps[2])) ))+
        scale_color_manual(values=allcolors[[scolorby]], na.value="#CCCCCC", guide = guide_legend(override.aes = list(size = legsize) ))+
        NoAxes()+
        ggtitle(paste0("curve", curves[cs], "_lambda"))+
        theme_classic()+
        NoLegend()+
        rotatex(90)
    })  %>% Reduce("+", .) 
    
    sca=.5*length(curves)
    #sca=4
    rr=600
    tpdf(path=params$outpath, paste_("sling_shot_trajectory_s10",subsetlabel, "clusters", paste(clustersubset, collapse="_"), "colorby", scolorby, "start_at", start.clus, "comps", paste(comps, collapse="_") ) , width=pw*sca, height=pw*sca)#,res=rr )
    print(sp1)
    dev.off()
    
  }) 
  
  
  
})
```

# Finding genes associated with the Pseudotime trajectory


## perform tradeSeq fitGAM on clusters with a certain number of knots
```{r}


simpleCache(paste_("tradeSeq_fitGAM_clusters", nkn, "knots", subsetlabel), {
  library(stringr)
  pseudotime <- slingPseudotime(sli, na = FALSE)
  cellWeights <- slingCurveWeights(sli, as.probs=T)
  counts=as.matrix(s10@assays$RNA@counts)
  
  top_expr_genes <- apply(s10@assays$RNA@counts>=3, 1, sum)
  top_expr_genes <- names(top_expr_genes)[top_expr_genes>=5]
  #exclude ribosomal and mitochondrial genes
  model_genes <- str_subset(top_expr_genes, "^MT-|^RP[LS]+[0-9]",negate = TRUE)
  
  
  ##indices of the good genes
  findgeneindices= function(so, genelist) sapply(1:length(genelist), function(g) which(grepl(paste0("^",genelist[g],"$"), rownames(so@assays$RNA@counts))))
  ii=sapply(1:length(model_genes), function(g) which(grepl(paste0("^",model_genes[g],"$"), rownames(s10@assays$RNA@counts))))
  
  sce <- fitGAM(counts = counts, pseudotime = pseudotime, cellWeights = cellWeights, nknots = nkn, verbose = TRUE, genes=ii)		
  list(sce, cellWeights)	 
}, assignToVar="outlst", reload=T)



sce=outlst[[1]]
curveweights=outlst[[2]]


################################################################################
# run tradeSeq tests of different nature.
################################################################################


simpleCache(paste_("tradeSeq_tests", nkn, "knots", subsetlabel), {
  assoRes <- associationTest(sce, lineages=TRUE)
  
  
  #In order to discover marker genes of the progenitor or differentiated cell population, researchers may be interested in assessing differential expression between the progenitor cell population (i.e., the starting point of a lineage) with the differentiated cell type population (i.e., the end point of a lineage). The function startVsEndTest uses a Wald test to assess the null hypothesis that the average expression at the starting point of the smoother (progenitor population) is equal to the average expression at the end point of the smoother (differentiated population). 
  
  
  startRes <- startVsEndTest(sce, lineages=TRUE)

  testlist=list(asso=assoRes, start=startRes)
  testlist
}, assignToVar="testlist", recreate=T)
```


## get genes associated with the trajectory (trajectory indicated by parameter nmr)

```{r}
################################################################################
###get associated genes and bin cells uniformly across the slingshot pseudotime
################################################################################

if(length(SlingshotDataSet(sli)@lineages)>1){
  ordervar=paste_("waldStat", nmr)}else{
    ordervar="waldStat"
  }
ordercurve=paste0("Lineage", nmr, ".lambda")

assotable=testlist$asso %>% filter(get(paste_("pvalue", nmr))<=pval, meanLogFC>=lt) %>% arrange(-(!!sym(ordervar))) %>% head(numsignificant)
assogenes=testlist$asso %>% filter(get(paste_("pvalue", nmr))<=pval, meanLogFC>=lt) %>% arrange(-(!!sym(ordervar))) %>% head(n=numsignificant)  %>% rownames



minlambda=slidf %>% arrange(!!sym(ordercurve)) %>% pull(!!sym(ordercurve)) %>% min
maxlambda=slidf %>% arrange(!!sym(ordercurve)) %>% pull(!!sym(ordercurve)) %>% max
stepsize=(maxlambda-minlambda)/nsteps
bins=seq(minlambda, maxlambda, stepsize)

binnedcells=lapply(1:(length(bins)-1), function(x)  slidf %>% filter(!!sym(ordercurve)>= bins[x], !!sym(ordercurve)<bins[x+1]) %>% pull(cell_id) ) #%>% Reduce(c, .)
binnedcells=unique(binnedcells %>% Reduce(c, .))


givename= function(x, nam) {
  colnames(x)= nam
  x
}

#single column dataframe, make named vecto from df. takes larger dfs but we just take the first column anyway
vecfromdf= function(dff) {
  vec= dff[,1]
  names(vec)= rownames(dff)
  
  vec
}

annodf=slidf  %>% filter(cell_id %in% binnedcells)  %>% col2names(., "cell_id") %>% select(clusters,type3) 
annodf2=annodf[binnedcells,] %>% select(type3)

sgenes=assogenes

if(clus){
  pl=ComplexHeatmap::pheatmap(s10@assays[[ass.use]]@data[sgenes,binnedcells] %>% as.matrix, 
                              scale="row", 
                              cluster_rows=TRUE, 
                              cluster_cols=FALSE) #,gaps_col=60, silent=T)
  
  
  cgenes=ComplexHeatmap::row_dend(pl) %>% as.hclust %>% cutree(nk) %>% sort 
  
  cgenenames=cgenes %>% names
  
  ###rearrange clusters in preferred display order: early, middle, late

  
  cgenes=rev(cgenes)
  rowgaps= cgenes %>% diff %>% as.logical %>% which
  sgenes=cgenes
}
```

## Reorder genes in each cluster based on seriation, to better see patterns. 
```{r}
mat=(s10@assays[[ass.use]]@data[sgenes %>% names,binnedcells] %>% as.matrix) 
clusmeans=c()
ct=1
sca=.3

s2genes=lapply(1: nk, function(nm){
  
  st= sgenes[sgenes==nm] %>% names
  ss=seriation::get_order(
    seriation::seriate(scale(mat[st,] %>% t) %>%t)
    , method="PCA")
  clusmeans[ct]<<-  sum(colMeans(scale((mat[st, ]) %>% t) %>%t)*(sapply(1:ncol(mat[st, ]), function(x) x**2, USE.NAMES=F)))
  ct<<-ct+1
  st[ss %>% unname]
})
ct=1
names(clusmeans)= 1:nk

s3classes=lapply(1:length(s2genes), function(x) rep(x, length(s2genes[[x]]))) %>% Reduce(c, .)
s3genes=s2genes %>% Reduce(c, .)
names(s3classes)= s3genes

rgenes=s3classes

#reordering according to positional means
neworder=clusmeans %>% sort %>% names
rgenes=lapply(neworder, function(tt) s3classes[s3classes==tt]) %>% Reduce(c, .)


rowgaps= rgenes %>% diff %>% as.logical %>% which



if(!marktransition){
  ntop=numsignificant
  geneguide=  1:length(rgenes %>% names)
  names(geneguide)=rgenes %>% names
  geneguide=geneguide[1:ntop]
  genecols= sapply(geneguide %>% names, colorgene2, USE.NAMES=F)
  ha = ComplexHeatmap::rowAnnotation(foo = ComplexHeatmap::anno_mark(at = geneguide[genecols!="grey"], labels = geneguide[genecols!="grey"] %>% names,   lines_gp= grid::gpar(col=genecols[genecols!="grey"]), labels_gp= grid::gpar(col=genecols[genecols!="grey"])))
}else{
  transitioncluster=c(5)
  geneguide=  1:length(rgenes %>% names)
  names(geneguide)=rgenes %>% names
  geneguide=geneguide[rgenes %in% transitioncluster ]
  genecols= sapply(geneguide %>% names, colorgene, USE.NAMES=F)
  ha = ComplexHeatmap::rowAnnotation(foo = ComplexHeatmap::anno_mark(at = geneguide, labels = geneguide %>% names,   lines_gp= grid::gpar(col=genecols), labels_gp= grid::gpar(col=genecols)))
  
}


runid= paste_(subsetlabel, "trajectory", nmr, "numgenes", numsignificant, "knots", nkn, "logfoldtrhesh", lt, "numclusters", nk)


################################################################################
# Supplementary figure 3 b.  slingshot trajectory associated genes heatmap
################################################################################

tpdf(path=params$outpath, paste_("pheatmap_tradeseq",runid), height=sca*pw*5.3, width=pw*sca*3)

pl=ComplexHeatmap::pheatmap(s10@assays[[ass.use]]@data[rgenes %>% names,binnedcells] %>% as.matrix, 
                            scale="row", 
                            cluster_rows=FALSE, 
                            cluster_cols=FALSE,
                            show_colnames=FALSE,
                            show_rownames=FALSE,
                            annotation_col=annodf2,
                            annotation_colors=allcolors,
                            border_color=NA,
                            breaks=br, 
                            gaps_row=rowgaps,
                            right_annotation=ha,
                            col=cmap) #,gaps_col=60, silent=T)

pl
dev.off()


fcat("Run ID: ", runid)

#data loading. skip if datasets are already loaded. 

simpleCache(paste_("tradeSeq_results_table",runid), {
  resultstable=assotable[rgenes %>% names,] %>% mutate(gene=rgenes %>% names, cluster=rgenes %>% unname, is.TF= lapply(rgenes %>% names, istf) %>% unlist, is.ligand=lapply(rgenes %>% names, isligand) %>% unlist, is.receptor=lapply(rgenes %>% names, isreceptor) %>% unlist, pseudotime.ID=subsetlabel, fitgam.knots=nkn)
  fwrite(resultstable, file= file.path(params$outpath, timestamp(paste0("resultstable_", runid, ".csv"))))
  resultstable
}, assignToVar="resultstable", recreate=T)


cellinfo.slingshot=list(); cellinfo.slingshot$markerlist=lapply(1:nk, function(x) cgenes[cgenes==x] %>% names)
cellinfo.slingshot$cell.list=list(mescym.fitgam5=binnedcells)

```



## Session info etc.

Runtime: `r time_diff(SETUP_TIME)`

```{r}
sessionInfo()
```

